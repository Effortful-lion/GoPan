[TOC]

# 第一章 操作系统概述

## 概括

本章重点考查`操作系统的功能、运行环境和提供的服务`。要求读者能从宏观上把握`操作系统各部分的功能`，`微观上掌握细微的知识点`。因此，复习操作系统时，首先要形成大体框架，并通过反复复习和做题巩固知识体系，然后将操作系统的所有内容串成一个整体。本章的内容有助于读者`整体上初步认识操作系统`。

## 操作系统的基本概念

### 计算机系统架构

```
								   用户
									|
								 应用程序
								    |
								 操作系统
                                	|
                                   硬件
```

### 操作系统职责

规定以何种方式，`控制和协调`各`用户`的`应用程序`对`硬件的分配和使用`,进而为用户和其他应用程序提供使用`接口`和`运行环境`的`集合`。

### 操作系统的基本特征

并发:`同一时间段`内多个进程执行。（并行：`同一时间点`内多个进程执行。）

共享:互斥共享、同时访问（分时共享） 

一般，并发和共享是相互依赖存在的。

虚拟:时分复用技术（虚拟处理器）；空分复用技术（虚拟存储器）

异步:并发执行，执行速度随机推进

### 操作系统的功能

**处理机管理**

处理机的分配和运行都以进程为基本单位。所以也可以叫：进程管理。进程管理的主要功能包括：进程控制、进程同步、进程通信、死锁处理、处理机调度等。

**存储器管理**

为程序运行提供良好的环境，方便用户使用以及提高内存的利用率。主要包括：内存分配和回收、地址映射、内存保护与共享和内存扩充等功能。

**文件管理**

计算机的信息都是以文件形存在的，操作系统中负责文件管理的部分称为文件系统。包括：文件存储空间管理、目录管理以及文件读写管理和保护等

**设备管理**

完成用户请求，方便用户使用各种设备，提高设备利用率。主要包括：缓冲管理、设备分配、设备处理和虚拟设备等功能。

### 操作系统的接口

**命令接口**

分为：联机命令接口（交互式命令接口）和 脱机命令接口。交互式命令接口就是单个命令执行且回应反馈。脱机命令接口是批处理一系列命令。

**程序接口**

通过系统调用函数，申请操作系统服务：申请内存、回收内存等（如：GUI的使用）

覆盖了软件的机器（裸机）称为扩充机器或虚拟机。

### 小结

![image-20250524165654156](https://gitee.com/young-lion/picture-bed/raw/master/202505241657653.png)

![image-20250524165734063](https://gitee.com/young-lion/picture-bed/raw/master/202505241657495.png)

## 操作系统的发展历程

### 手工操作阶段（无操作系统）

缺点：用户独占全机、cpu利用率低

### 批处理阶段（操作系统开始出现）

单道批处理系统：自动、顺序、单道

多道批处理系统：单道的基础上（无顺序），多道执行，出现并发（cpu切换[切换时机：阻塞后切换]进行：宏观并发、微观串行）

`批处理`：响应时间长、`无交互`

### 分时操作系统

特点：

同时性：`(多终端)`多个终端用户可以共享一台计算机

`交互性：终端人机交互`

独立性：多个用户独立操作

及时性：及时获得响应

### 实时操作系统

硬实时操作系统：严格在时间限制内，完成某一任务

软实时操作系统：可以接受时间延误

特点：可靠性和及时性

### 网络操作系统

将计算机网络中所有计算机连接，实现各台计算机之间数据传输

### 分布式计算机系统

- 任意两台计算机可以通过通信方式交换信息
- 每台计算机同等地位
- 每台计算机的资源为所有用户共享
- 任意台计算机可构成子系统且可重构
- 若干个计算机协同完成一个任务

### 个人计算机系统

windows、linux、macos等

### 小结

![image-20250525090615625](https://gitee.com/young-lion/picture-bed/raw/master/202505250906770.png)

1. 分时操作系统为什么响应时间好？

   因为分时系统采用了时间片轮转的方法，使得每个任务在较短的时间内得到响应

2. 提高单机资源利用率的关键技术是？

   多道程序设计技术

3. 时间片固定，用户数越多，响应时间越长。

4. ![image-20250525095127193](https://gitee.com/young-lion/picture-bed/raw/master/202505250951693.png)

## 操作系统运行环境

### CPU运行模式

内核模式与用户模式即：内核态和用户态

内核态下执行特权指令，用户态下执行非特权指令。

特权指令：不允许用户直接调用（可通过应用程序间接调用）的指令。如：内核态切换用户态的（访管指令）指令、io指令、关中断指令、内存清零指令等

非特权指令：允许用户直接调用的指令。访问仅限于用户的地址空间中，防止应用程序对系统造成破环。

内核的构成：根据软件工程和结构化程序设计方法的影响下，现代操作系统结构几乎都是分层式的。

```
|---------------------------------------------------------|
|						   内核				             |
|			进程管理、存储器管理、设备管理等（相对频繁）         |
|														  |
|	        时钟管理、中断处理、设备驱动等（相对底层）           |
|---------------------------------------------------------|
						   硬件
```

内核实际上就是包括 4 方面内容：

1. 时钟管理（计时提供时钟服务。很多系统操作需要时间，比如：cpu调度时间片轮转、实时操作系统中按截止时间控制运行、批处理通过时间衡量任务进度）
2. 中断机制（中断机制的引入其实是为了用于多道程序设计，提高cpu利用率。后来扩展：进程的管理和调度、键盘或鼠标信息的输入、系统功能的调用）
3. 原语（系统底层可调用的程序。特点：原子性、使用频繁性、最接近底层。定义一个原语核心在于”关中断“，保证原子性）
4. 系统控制的数据结构及处理（用于存储的数据结构有好多：作业控制块、进程控制块、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。常见的管理操作有 3 种：进程管理、存储器管理、设备管理）

### 中断和异常的处理

![image-20250527142409118](https://gitee.com/young-lion/picture-bed/raw/master/202505271424568.png)

1. 中断和异常的区别
2. 中断和异常的处理
3. 中断和异常的触发场景

### 系统调用

![image-20250527144323046](https://gitee.com/young-lion/picture-bed/raw/master/202505271443306.png)

1. 什么是系统调用？
2. 系统调用为什么是必须的？
3. 系统调用和库函数的区别？
4. 系统调用的过程？

### 程序的链接与装入

`程序装入`

**一、程序装入的核心概念**

**程序装入**的本质是将外存（如硬盘）中的程序二进制代码加载到内存（RAM）中，供 CPU 读取和执行。
在此过程中，需要解决一个关键问题：**程序中的逻辑地址（指令 / 数据的原始地址）如何映射到内存的物理地址**。
不同的装入方式对应不同的地址映射策略，主要分为以下三种：

**二、三种装入方式的详细说明**

**1. 绝对装入（Absolute Loading）**

- **核心逻辑**：
  直接将程序中的**逻辑地址视为物理地址**，装入程序按固定的物理地址存储程序代码。
  **前提条件**：必须明确知道程序在内存中的具体物理地址，且程序中所有地址均为绝对物理地址。
- **举例**：
  若程序中某条指令的逻辑地址为`0x1000`，装入程序直接将其放入内存物理地址`0x1000`处。
- 适用场景
  - 单道程序环境（如早期简单操作系统）。
  - 内存空间固定且程序无需动态调整的场景（如嵌入式系统的固化程序）。
- 局限性
  - 程序无法在内存中移动（物理地址固定）。
  - 多程序共存时易引发地址冲突（如两个程序都使用`0x1000`地址）。

**2. 可重定位装入（Relocatable Loading）**

- **核心逻辑**：
  程序中的地址均为**逻辑地址（相对地址）**，装入时由装入程序统一将所有逻辑地址转换为**内存中的物理地址**，这个过程称为**静态重定位**。
  **关键操作**：将程序的逻辑地址空间映射到内存的物理地址空间，且**重定位在程序运行前一次性完成**。
- **举例**：
  程序的逻辑地址从`0`开始（如指令`MOV AX, [100]`中的`100`是逻辑地址），装入时若内存起始地址为`0x8000`，则所有逻辑地址需加上`0x8000`，转换为物理地址`0x8100`。
- 核心修正
  - **不是虚拟地址到内存地址的映射**（虚拟地址是操作系统引入分页 / 分段机制后的概念）。
  - 可重定位装入处理的是**逻辑地址（相对地址）到物理地址的直接转换**，不涉及虚拟内存机制（虚拟内存属于动态运行时装入的延伸）。
- 适用场景
  - 多道程序环境中，程序可装入内存的任意连续区域（通过重定位避免地址冲突）。
  - 早期不支持虚拟内存的操作系统（如 DOS）。

**3. 动态运行时装入（Dynamic Run-Time Loading）**

- **核心逻辑**：
  程序装入内存时，**不立即进行地址重定位**，而是将重定位推迟到**程序运行期间**，由**硬件地址转换机制（如 MMU，内存管理单元）\**动态完成逻辑地址到物理地址的映射。
  \*\*关键技术\*\*：结合虚拟内存技术（分页 / 分段），程序使用\**虚拟地址**，运行时通过页表 / 段表转换为物理地址。
- **举例**：
  程序中的指令使用虚拟地址`0x1000`，运行时 MMU 根据页表将其转换为物理地址`0x80001000`（假设页号对应物理页基址为`0x80000000`）。
- 核心修正
  - **不是延迟加载模块**（延迟加载属于程序加载策略，如动态链接库的按需加载）。
  - 动态运行时装入的核心是**运行时动态地址转换**，与模块是否延迟加载无直接关联。
- 适用场景
  - 现代操作系统（如 Windows、Linux）均采用此方式，支持虚拟内存、程序动态扩展和内存共享。

**三、对比总结**

| **装入方式**   | **重定位时机** | **地址类型**     | **核心依赖**            | **典型场景**           |
| -------------- | -------------- | ---------------- | ----------------------- | ---------------------- |
| 绝对装入       | 装入时（静态） | 物理地址（绝对） | 固定内存地址            | 单道程序、嵌入式系统   |
| 可重定位装入   | 装入时（静态） | 逻辑地址（相对） | 装入程序的重定位计算    | 多道程序（无虚拟内存） |
| 动态运行时装入 | 运行时（动态） | 虚拟地址         | 硬件 MMU 和操作系统页表 | 现代多任务操作系统     |

**四、常见误区澄清**

1. **虚拟地址 vs. 逻辑地址**：
   - 逻辑地址是程序编写时使用的相对地址（如 C 语言中的指针）。
   - 虚拟地址是操作系统引入虚拟内存后，逻辑地址通过分段 / 分页机制转换后的中间地址（仅在支持虚拟内存的系统中存在）。
   - 可重定位装入处理的是逻辑地址→物理地址，动态运行时装入处理的是虚拟地址→物理地址。
2. **延迟加载 vs. 动态重定位**：
   - 延迟加载（Lazy Loading）指程序模块在需要时才加载到内存（如动态库`dll`），属于**加载策略**。
   - 动态运行时装入的核心是**地址转换时机**，与加载策略无关（程序可能已全部加载到内存，但地址转换在运行时进行）。

通过以上解析，可以更清晰地区分三种装入方式的本质差异及其在操作系统中的实际应用。

**`程序的链接`**

**一、程序链接的基本概念**

**程序链接（Linking）\**是将\**多个目标模块（Object Modules）**（包括源代码编译生成的目标文件、引用的库文件等）组合成一个 ** 可执行文件（Executable）**或**库文件（Library）** 的过程。
其核心任务包括：

1. **符号解析（Symbol Resolution）**：处理模块间的函数、变量引用（如第三方库中的函数调用）。
2. **地址和空间分配（Address and Storage Allocation）**：为每个模块分配内存地址空间。
3. **重定位（Relocation）**：修正目标模块中的地址引用，使其指向正确的内存位置。

**二、程序链接的分类**

根据链接时机的不同，可分为三种主要方式：**静态链接（Static Linking）**、**动态链接（Dynamic Linking）\**和\**动态加载（Dynamic Loading）**。

**1. 静态链接（Static Linking）**

- 过程

  在编译阶段，将目标文件与静态库（.a/.lib）**中的代码**直接合并到可执行文件中。

  - 例如：C 语言程序引用`printf`函数时，若使用静态链接，会将标准库中`printf`的代码复制到可执行文件中。

- 特点

  - 可执行文件**包含所有依赖的库代码**，无需外部库即可运行。
  - 缺点
    - 生成的文件体积较大（重复包含公共库代码）。
    - 库更新时需重新编译整个程序。

- 适用场景

  - 嵌入式系统或需要独立运行的程序（如无库环境的场景）。

**2. 动态链接（Dynamic Linking）**

- 过程

  在编译阶段，仅记录 ** 目标文件对动态库（.so/.dll）** 的引用关系，不直接合并库代码

  - 可执行文件运行时，由操作系统的 ** 动态链接器（Dynamic Linker）** 加载所需的动态库，并完成地址重定位。

- 特点

  - 可执行文件体积小（仅存储库的引用信息）。
  - 多个程序可共享同一动态库的内存实例，节省内存。
  - 库更新后，无需重新编译程序（需保持接口兼容）。

- 关键操作

  - **符号解析**：确定动态库中函数 / 变量的实际地址。
  - **延迟绑定（Lazy Binding）**：首次调用库函数时才进行地址解析，提升程序启动速度。

- 适用场景

  - 现代操作系统中的大多数应用程序（如 Windows 的`.dll`、Linux 的`.so`）。

**3. 动态加载（Dynamic Loading）**

- **过程**：
  程序在**运行时**通过 API（如 Linux 的`dlopen`、Windows 的`LoadLibrary`）**显式加载动态库**，并获取库中函数 / 变量的地址。
- 特点
  - 灵活性极高，可在运行时按需加载模块（如插件系统）。
  - 库的加载和卸载由程序控制，无需在启动时全部加载。
- 适用场景
  - 插件化架构（如浏览器扩展、IDE 插件）。
  - 动态更新组件（如游戏模组）。

**三、链接与装入的关系**

链接和装入是程序运行前的两个关键步骤，二者的区别和联系如下：

| **阶段** | **核心任务**                     | **处理对象**       | **依赖技术**              |
| -------- | -------------------------------- | ------------------ | ------------------------- |
| **链接** | 合并目标文件和库，解析符号引用   | 目标文件（.o）、库 | 符号表、重定位表          |
| **装入** | 将可执行文件加载到内存并分配地址 | 可执行文件         | 地址重定位（静态 / 动态） |

- **静态链接→绝对装入 / 可重定位装入**：
  静态链接后的可执行文件可直接通过绝对装入或可重定位装入加载到内存。
- **动态链接→动态运行时装入**：
  动态链接的可执行文件需在运行时结合动态库加载和动态地址转换（如 MMU 的虚拟地址映射）。

**四、常见误区澄清**

1. **“链接只是合并代码”**：
   - 错误。链接的核心是**符号解析和地址重定位**，合并代码仅是静态链接的表现形式之一。动态链接不合并代码，仅建立引用关系。
2. **“第三方库只能通过静态链接合并”**：
   - 错误。第三方库既可以编译为静态库（.a/.lib，静态链接时合并），也可以编译为动态库（.so/.dll，动态链接时按需加载）。
3. **“链接等于编译”**：
   - 错误。编译是将源代码转换为目标文件（.o）的过程，链接是将目标文件和库整合为可执行文件的过程，二者属于编译流程的不同阶段。

**五、总结**

程序链接的本质是**解决模块间的依赖关系**，而非简单的代码合并。静态链接通过物理合并库代码实现独立运行，动态链接通过运行时加载库实现高效内存共享，动态加载则进一步赋予程序运行时动态扩展的能力。理解这些机制有助于深入掌握软件开发流程和操作系统的程序执行原理。

**`程序运行时内存映像与地址空间`**

程序运行时的内存映像（Memory Image）和地址空间（Address Space）是操作系统管理程序执行的核心概念，二者共同决定了程序在内存中的布局和资源访问方式。以下从原理、结构、机制等方面展开讲解：

**一、程序运行时的内存映像**

**内存映像**指程序加载到内存后，其代码和数据在内存中的具体分布结构。不同操作系统（如 Linux、Windows）的内存映像布局略有差异，但核心区域基本一致。以典型的 C 程序为例，内存映像通常包含以下几个部分：

**1. 代码段（Text Segment）**

- **内容**：存储程序的可执行代码（机器指令）、只读常量（如`const`修饰的变量）和字符串字面量（如`"Hello World"`）。
- 特点
  - **只读**：防止程序运行时意外修改代码（保护程序逻辑）。
  - **可共享**：多个运行实例可共享同一代码段（如同一程序多次启动），节省内存。
- **示例**：函数体中的指令、`main`函数的代码均位于此区域。

**2. 数据段（Data Segment）**

- 内容

  ：存储已初始化的全局变量和静态变量

  - **初始化全局变量**：如`int global_var = 10;`。
  - **静态变量**：如函数内的`static int static_var = 5;`。

- 特点

  - **可读可写**：程序运行时可修改其值。
  - **生命周期**：随程序启动而创建，程序结束后释放。

**3. BSS 段（Block Started by Symbol）**

- 内容

  ：存储

  未初始化的全局变量和静态变量

  - 例如：`int global_var;`（未赋值）、`static int static_var;`（未初始化）。

- 特点

  - **不占用磁盘空间**：编译时仅记录变量名称和类型，运行时由操作系统自动初始化为`0`或`NULL`。
  - **节省内存**：未初始化的变量无需在可执行文件中存储默认值。

**4. 堆（Heap）**

- **内容**：动态分配的内存区域，用于存储程序运行时动态申请的内存（如 C 语言的`malloc`/`free`、C++ 的`new`/`delete`）。
- 特点
  - **向上增长**：从低地址向高地址扩展（与栈的增长方向相反）。
  - **手动管理**：需程序员显式申请和释放，若未释放会导致内存泄漏。
- **示例**：`int* ptr = (int*)malloc(sizeof(int));`分配的内存位于堆区。

**5. 栈（Stack）**

- 内容

  ：存储函数调用时的临时数据包括：

  - **函数参数**、**局部变量**、**返回地址**、** 调用栈帧（Stack Frame）** 等。

- 特点

  - **向下增长**：从高地址向低地址扩展。
  - **自动管理**：函数调用结束后，栈帧自动销毁，数据释放。
  - **大小受限**：操作系统通常限制栈的最大大小（如 Linux 默认约 8MB），递归过深会导致栈溢出（Stack Overflow）。

- **示例**：函数内定义的`int localVar = 10;`存储在栈区。

**6. 其他区域（可选）**

- **共享库映射区**：存储动态链接库（如 Linux 的`.so`、Windows 的`.dll`）的代码和数据，供程序运行时调用。
- **内核映射区**：操作系统内核在用户进程地址空间中的映射（仅内核态可访问）。

**二、程序的地址空间（Address Space）**

**地址空间**指程序在运行时可访问的内存地址范围。现代操作系统（如 Linux、Windows）普遍采用**虚拟内存（Virtual Memory）\**技术，为每个进程分配独立的\**虚拟地址空间**，通过地址转换机制（如 MMU，内存管理单元）映射到物理内存。

**1. 虚拟地址空间的结构（以 32 位 Linux 为例）**

32 位系统中，每个进程拥有**4GB 虚拟地址空间**，分为**用户空间**和**内核空间**两部分：

| 区域         | 地址范围                          | 用途                                                         |
| ------------ | --------------------------------- | ------------------------------------------------------------ |
| **用户空间** | 0x00000000 ~ 0xBFFFFFFF（约 3GB） | 存储程序的代码、数据、堆、栈及动态库等，用户态程序可直接访问。 |
| **内核空间** | 0xC0000000 ~ 0xFFFFFFFF（约 1GB） | 存储操作系统内核代码和数据，仅内核态（通过系统调用）可访问。 |

## 操作系统结构

操作系统结构（以内核的结构构成进行分类）

![image-20250527145303959](https://gitee.com/young-lion/picture-bed/raw/master/202505280917479.png)

![](https://gitee.com/young-lion/picture-bed/raw/master/202505271520691.png)

1. 操作系统的结构
2. 操作系统各种结构的优缺 
3. 操作系统中各种结构的作用

## 操作系统引导

![image-20250527155857411](https://gitee.com/young-lion/picture-bed/raw/master/202505271558461.png)

操作系统的开机引导：

1. 主存 = RAM +ROM 部分。然后 RAM 是我们经常说的内存部分，ROM 主要就是我们的 BIOS 系统。负责开机的引导第一步：执行其中的自举程序。
2. 通过 ROM 中的自举程序找到磁盘的主引导记录和分区表，读取到内存中，并执行。
3. 通过 执行 主引导记录中的程序找到 整个磁盘的活动分区表也就是我们安装操作系统的分区。读取其中的引导记录 PBR 并执行其中的程序。
4. 通过 执行 PBR 中的程序找到 C 盘中的根目录下的启动管理器（即：操作系统的初始化程序），完成开机。

## 虚拟机

![image-20250527160719267](https://gitee.com/young-lion/picture-bed/raw/master/202505271607975.png)

但是，由于考虑到对物理资源的利用率不高，我们想要运行更多的进程且进程间可以独立不受干扰。那就将一台物理机虚拟为多台“虚拟机”。

![image-20250527161744987](https://gitee.com/young-lion/picture-bed/raw/master/202505280916524.png)

虚拟机管理系统分为两类：直接运行并分配硬件资源、运行在宿主机上硬件资源需要操作系统进行分配。

![image-20250527162907030](https://gitee.com/young-lion/picture-bed/raw/master/202505280916810.png)

一二类虚拟机的区别？

------



# 第二章 进程管理

## 进程和线程相关概念

**进程的定义和组成**

![image-20250527164458582](https://gitee.com/young-lion/picture-bed/raw/master/202505271645895.png)

**进程的特征**

![image-20250527164730919](https://gitee.com/young-lion/picture-bed/raw/master/202505271647329.png)

在引入 线程 之后，进程不再是调度的基本单位。但是仍然是资源分配的基本单位

![](https://gitee.com/young-lion/picture-bed/raw/master/202505271701621.png)

**问：进程从运行态通过系统调用为什么会进入阻塞态？想问的是：为什么系统调用会使得进程阻塞？**

当进程发起系统调用时，CPU 会从用户态切换到内核态，由内核处理请求。**若内核无法立即完成请求**（例如需要等待 I/O 设备响应、网络数据到达或锁释放），进程会进入阻塞态以释放 CPU 资源。

![image-20250527170235120](https://gitee.com/young-lion/picture-bed/raw/master/202505271702669.png)

**进程的组织-链接方式**

就是操作系统是如何将进程的 PCB 进行组织和链接的？

两种：链式 和 索引 形式

链式：就是不同状态的队列

![image-20250527170640588](https://gitee.com/young-lion/picture-bed/raw/master/202505271706155.png)

索引方式：（不常用）

![image-20250527170731069](https://gitee.com/young-lion/picture-bed/raw/master/202505271707217.png)

### 进程控制

![image-20250527170959115](https://gitee.com/young-lion/picture-bed/raw/master/202505280941017.png)

进程控制就是实现进程的状态转换

创建原语：

![image-20250528094149715](https://gitee.com/young-lion/picture-bed/raw/master/202505280941026.png)

终止原语：

![image-20250528095041525](https://gitee.com/young-lion/picture-bed/raw/master/202505280950557.png)

阻塞原语：阻塞和唤醒成对出现，由谁阻塞由谁唤醒

![image-20250528095013807](https://gitee.com/young-lion/picture-bed/raw/master/202505280950814.png)

进程切换

![image-20250528100154321](https://gitee.com/young-lion/picture-bed/raw/master/202505281001314.png)

### 进程通信

什么是进程间通信？涉及到两个及以上的进程间有操作关系。

进程间通信的方式：1. 共享内存方式  2. 消息传递方式

**共享内存方式**

1. 操作系统通过提供一块共享内存块，让其他进程将共享内存块映射到我们的独立的虚拟空间。

   ![image-20250528102931157](https://gitee.com/young-lion/picture-bed/raw/master/202505281029014.png)

2. 消息通信，进程间通过发送消息

   消息通信又分为两种方式：直接通信方式和间接通信方式
   
   **直接通信：**
   
   ![image-20250529081346984](https://gitee.com/young-lion/picture-bed/raw/master/202505290813959.png)
   
   **间接通信：**
   
   ![image-20250529081320571](https://gitee.com/young-lion/picture-bed/raw/master/202505290813026.png)
   
3. 管道通信：通过一个内存共享区的缓冲区，但是和一般的内存共享区区别：一般的内存共享区可以在任意位置读写。但是管道只能按照队列的方式进行读写（先进先出）。而且从数据结构的角度看，这个管道其实是一个循环队列。

![image-20250529083627755](https://gitee.com/young-lion/picture-bed/raw/master/202505290836921.png)

### 信号

**信号如何发送？**

通过调用发送信号的函数

**信号是如何进行保存的？**

通过位变量，对每种类型的信号进行保存。有待处理信号...

![image-20250529084853526](https://gitee.com/young-lion/picture-bed/raw/master/202505290848942.png)

**待处理信号和被阻塞信号是哪来的？**

待处理信号就是通过其他进程进行传递的

被阻塞信号就是通过系统调用自行设置的（自行决定屏蔽）

**哪些信号需要被处理？**

通过待处理信号和被阻塞信号进行位运算：处理信号 = 待处理信号 & ~被阻塞信号 （其中为1的类型的信号将被处理）

**信号处理的时机是什么时候？**

当进程从内核态转用户态时

**信号检查的时机和中断检查的时机分别在什么时候？**

信号检查：当进程从内核态转用户态时

中断检查：当进程从用户态转内核态时

**注意：**

进程间进行信号发送时，只能父进程向子进程进行发送。

或者 内核级进程 向 任意进程进行发送

![image-20250529104904027](https://gitee.com/young-lion/picture-bed/raw/master/202505291049782.png)

### 线程相关概念

![image-20250529105034559](https://gitee.com/young-lion/picture-bed/raw/master/202505291050590.png)

![image-20250529111855911](https://gitee.com/young-lion/picture-bed/raw/master/202505291118708.png)

![image-20250529112336054](https://gitee.com/young-lion/picture-bed/raw/master/202505291123270.png)

线程实现方式：用户级线程和内核级线程

多线程模型：一对一、多对一、多对多

![image-20250529115719842](https://gitee.com/young-lion/picture-bed/raw/master/202505291157580.png)

![image-20250529115649200](https://gitee.com/young-lion/picture-bed/raw/master/202505291156171.png)

![image-20250529115636187](https://gitee.com/young-lion/picture-bed/raw/master/202505291156611.png)

![image-20250529115550341](https://gitee.com/young-lion/picture-bed/raw/master/202505291155325.png)

## 调度

### 调度的概念和层次

![image-20250529142810753](https://gitee.com/young-lion/picture-bed/raw/master/202505291428932.png)

### 进程调度的时机、切换以及切换过程、调度方式

![image-20250529144803571](https://gitee.com/young-lion/picture-bed/raw/master/202505291448982.png)

### 闲逛进程

当就绪队列中没有就绪的进程时，那么 cpu 并不会空闲，而是会去执行默认的 闲逛进程。

### 调度算法的指标

![image-20250529150912359](https://gitee.com/young-lion/picture-bed/raw/master/202505291509519.png)

### 调度算法

#### 先来先服务（FCFS）

![image-20250602162516003](https://gitee.com/young-lion/picture-bed/raw/master/202506021625197.png)

![image-20250602162607805](https://gitee.com/young-lion/picture-bed/raw/master/202506021626268.png)

#### 短作业优先（SJF）

![image-20250602163651289](https://gitee.com/young-lion/picture-bed/raw/master/202506021636491.png)

![image-20250602164048305](https://gitee.com/young-lion/picture-bed/raw/master/202506021640509.png)

那其实，当所有进程同时（或者说几乎同时到达），此时，非抢占式和抢占式的短作业优先算法的结果是相同的选择。

![image-20250602164435566](https://gitee.com/young-lion/picture-bed/raw/master/202506021644492.png)

至于，为什么非抢占式并不是一定“最短的平均等待时间”？因为，非抢占式一定会局部出现“先来先服务”的情况。整体的短作业优先算法的规则：1. 先到达 2. 作业时间最短（两个条件）

#### 高响应比优先算法（HRRN）

 ![image-20250602165201992](https://gitee.com/young-lion/picture-bed/raw/master/202506021652107.png)

![image-20250602165145481](https://gitee.com/young-lion/picture-bed/raw/master/202506021651502.png)

#### 时间片轮转调度算法（RR）

分时、公平式、被动放弃（时钟中断） + 主动放弃（进程结束）

时间片过大，退化为先来先服务（一个时间片内足够所有任务完成）

时间片过小，cpu切换频繁，大量开销

#### 优先级调度算法

优先级、抢占式 + 非抢占式 都有

![image-20250603083846555](https://gitee.com/young-lion/picture-bed/raw/master/202506030838795.png)

![image-20250603083918734](https://gitee.com/young-lion/picture-bed/raw/master/202506030839194.png)

#### 多级反馈队列调度算法

![image-20250603084024291](https://gitee.com/young-lion/picture-bed/raw/master/202506030840187.png)

![image-20250603084713734](https://gitee.com/young-lion/picture-bed/raw/master/202506030847999.png)

#### 多级队列调度算法

![image-20250603094705457](https://gitee.com/young-lion/picture-bed/raw/master/202506030947999.png)

#### 多处理机调度

![image-20250603115728546](https://gitee.com/young-lion/picture-bed/raw/master/202506031157376.png)

#### 进程互斥的软件实现方法

![image-20250603150932617](https://gitee.com/young-lion/picture-bed/raw/master/202506031509472.png)

单标志：使用 turn 变量，表示谦让

双标志：使用 turn 变量，表示谦让；使用 flag数组 eg：表示flag[0]=true/false，表示0号进程想要处理机

#### 互斥锁

出现忙等“自旋”

#### 信号量

![image-20250603154659193](https://gitee.com/young-lion/picture-bed/raw/master/202506031547199.png)

记录型信号量机制，需要等待的进程会自己调用阻塞原语进行自我阻塞操作

#### 信号量机制实现互斥、同步、前驱关系

![image-20250603154958434](https://gitee.com/young-lion/picture-bed/raw/master/202506031550355.png)

#### 死锁

死锁的概念&死锁产生的条件&死锁的处理策略

![image-20250604101837320](https://gitee.com/young-lion/picture-bed/raw/master/202506041018463.png)

#### 小结

**一、进程基本概念**

1. **定义**：进程是程序在操作系统中的一次执行实例，是资源分配和调度的基本单位。它包含程序代码、数据集合、进程控制块（PCB）以及运行时的系统资源（如内存、打开文件等）。

1. **进程控制块（PCB）**：操作系统用于管理进程的核心数据结构，存储进程 ID、状态、优先级、程序计数器、寄存器值、资源分配信息等关键信息，是进程存在的唯一标志。

1. **进程与程序区别**：程序是静态的代码文件，进程是动态的执行过程；同一程序可对应多个进程（如同时打开多个文本编辑器窗口）。

**二、进程状态与转换**

1. **基本状态**

- - **就绪态**：进程已获得除 CPU 外的所有必要资源，等待被调度执行。

- - **运行态**：进程正在 CPU 上执行。

- - **阻塞态**：因等待 I/O 操作、信号量或其他资源而暂停执行，处于非活动状态。

1. **状态转换**

- - 就绪态→运行态：被进程调度器选中分配 CPU。

- - 运行态→就绪态：时间片用完或被高优先级进程抢占。

- - 运行态→阻塞态：发起 I/O 请求或等待资源时主动暂停。

- - 阻塞态→就绪态：等待的事件完成（如 I/O 操作结束）。

**三、进程调度**

1. **调度目标**：提高 CPU 利用率、保证公平性、减少响应时间、提升吞吐量。

1. **调度算法**

- - **先来先服务（FCFS）**：按进程到达顺序调度，实现简单但可能导致短作业等待长作业，不利于交互性任务。

- - **短作业优先（SJF）**：优先调度预计执行时间最短的进程，可降低平均等待时间，但存在 “饥饿” 问题（长作业长期无法执行）。

- - **时间片轮转（RR）**：为每个进程分配固定时间片，时间片耗尽后切换，适用于分时系统，保证公平性。

- - **优先级调度**：按进程优先级分配 CPU，可分为静态优先级（创建时确定）和动态优先级（运行中调整），可能导致低优先级进程饥饿。

- - **多级反馈队列**：设置多个优先级队列，新进程进入高优先级队列，按时间片轮转执行；未完成则降级至低一级队列，兼顾响应时间和资源利用率。

**四、进程同步与互斥**

1. **临界资源与临界区**：一次仅允许一个进程访问的资源称为临界资源，访问临界资源的代码段称为临界区。

1. **同步机制**

- - **信号量**：通过 P（等待）和 V（释放）操作实现进程同步与互斥，如用二元信号量实现互斥，用计数信号量控制资源数量。

- - **管程**：封装共享资源及对其操作的代码，通过条件变量实现进程同步，避免信号量使用中的复杂逻辑错误。

1. **经典问题**

- - **生产者 - 消费者问题**：通过信号量协调生产者和消费者对共享缓冲区的操作，解决同步与互斥问题。

- - **读者 - 写者问题**：允许多个读者同时访问共享资源，但写者访问时需独占，可通过读写锁优化性能。

- - **哲学家就餐问题**：避免多个进程因竞争资源导致死锁，可通过资源分配策略（如同时分配所有资源）或打破死锁必要条件解决。

**五、死锁**

1. **定义**：多个进程因竞争资源而形成循环等待链，导致所有进程无法继续执行。

1. **死锁必要条件**：互斥条件、占有并等待条件、不可剥夺条件、循环等待条件。

1. **处理策略**

- - **预防死锁**：打破死锁四个必要条件中的一个（如采用资源静态分配法破坏占有并等待条件）。

- - **避免死锁**：通过银行家算法动态评估资源分配安全性，拒绝可能导致死锁的分配请求。

- - **检测与解除**：定期检测系统是否存在死锁，发现后通过撤销进程、剥夺资源等方式解除死锁。

以上全面总结了进程管理核心知识。如果你想深入了解某个知识点，或是需要更多相关案例分析，欢迎随时告诉我。

## 第三章 内存

#### 内存基础知识

![image-20250605091536293](https://gitee.com/young-lion/picture-bed/raw/master/202506050915655.png)

#### 内存管理概念

![image-20250605092427824](https://gitee.com/young-lion/picture-bed/raw/master/202506050924389.png)

#### 内存保护

![image-20250605092457474](https://gitee.com/young-lion/picture-bed/raw/master/202506050924986.png)

#### 内存映像

![image-20250605093745083](https://gitee.com/young-lion/picture-bed/raw/master/202506050937840.png)

![image-20250605093809827](https://gitee.com/young-lion/picture-bed/raw/master/202506050938785.png)

#### 覆盖与交换

![image-20250605095841225](https://gitee.com/young-lion/picture-bed/raw/master/202506050958721.png)

#### 内存分配（连续分配方式）

![image-20250605150348046](https://gitee.com/young-lion/picture-bed/raw/master/202506051503139.png)

内存分配（动态分配方式）

![image-20250605160851860](C:/Users/11067/Desktop/assets/image-20250605160851860.png)

#### 分页存储管理

![image-20250607120452687](https://gitee.com/young-lion/picture-bed/raw/master/202506071205269.png)

1. 进程的逻辑地址空间——页表——内存块——内存的关系

```
1. 进程拥有独立的进程空间，每一个进程空间也是“页管理”
2. 页表：页号（隐含）+块号。块既对应逻辑空间的页，也对应物理空间的页（内存块）
3. 内存块：在物理空间的“页框”
三者的“页”（最小管理单元）对应，但是大小可能不同。页表更倾向于一种记录型的映射结构

注意：页表项并不是和内存块一一对应的
```

#### 如何实现地址转换

![image-20250607122156025](https://gitee.com/young-lion/picture-bed/raw/master/202506071221013.png)

2的整数次幂使得在计算页号和偏移量时更快

```
逻辑地址转换为物理地址的四件事：
1. 由 逻辑地址 获得页号、页内偏移量
2. 通过 页表 获得 页块
3. 计算 物理地址 = 页块 * 页大小 + 页内偏移量
注意：由于 乘法 的效率很低，所以当使用 2 的整数次幂时，会发现，在 32 位计算机中，页大小为 4KB = 2的12次方，因此，32位的前20位为整数位（页号），后12位为余数位（页内偏移量）的二进制表示。因此可以更快的拆分出 页号 + 页内偏移量
```

![image-20250607123536667](https://gitee.com/young-lion/picture-bed/raw/master/202506071235822.png)

页表寄存器：存储 页表 的 页表起始地址 和 页表长度（一种基于内存的地址变换机构）

页表项大小的进一步探讨：

![image-20250607124507860](https://gitee.com/young-lion/picture-bed/raw/master/202506071245318.png)

具有快表的地址变换结构：（基于 cpu高速缓存）

![image-20250607125235598](https://gitee.com/young-lion/picture-bed/raw/master/202506071252749.png)

访存：访问内存（查询慢表、目标内存单元速度相同）

#### 两级页表

![image-20250607130754815](https://gitee.com/young-lion/picture-bed/raw/master/202506071307907.png)

```
这里其实说的是：页表结构也需要存在内存中，每一个页表很大，一个页表项一般为4kb，一般页表大小为2的20次方个页表项。一个内存块就是一个页面

但是：如果整个页表都存在内存中，就需要一段很大的连续内存，而且可能产生页内碎片。这与我们离散型存储的思想相悖。所以我们对页表页进行离散式的存储。设置二级页表，用于记录 页表号、内存块号。

根据页表号找到对应的内存块。然后就是典型的单级页表的查询方式了。

这样情况下，原先的地址，比如32位：前10位为 页表号，中间10位为 页号，后面11位 为页内偏移量
```

![image-20250607131642889](https://gitee.com/young-lion/picture-bed/raw/master/202506071316798.png)

总结：

![image-20250607132130287](https://gitee.com/young-lion/picture-bed/raw/master/202506071321261.png)

#### 分段存储管理

![ ](https://gitee.com/young-lion/picture-bed/raw/master/202506071338959.png)

#### 分段和分页的对比

![image-20250607140816788](https://gitee.com/young-lion/picture-bed/raw/master/202506071408488.png)

![image-20250607141117350](https://gitee.com/young-lion/picture-bed/raw/master/202506071411499.png)

#### 段页式管理方式

![image-20250607141621512](https://gitee.com/young-lion/picture-bed/raw/master/202506071416068.png)

![image-20250607141823710](https://gitee.com/young-lion/picture-bed/raw/master/202506071418808.png)

#### 虚拟内存

![image-20250608123850379](https://gitee.com/young-lion/picture-bed/raw/master/202506081238418.png)

#### 请求分页管理方式

![image-20250608125317462](https://gitee.com/young-lion/picture-bed/raw/master/202506081253982.png)

#### 页面置换算法

目的：选择换出哪个页面。尽量降低缺页率。

缺页率 = 缺页次数 / 整体请求页数量

#### 最佳置换算法（opt）

简单的说，就是换出长时间不会被访问的页面。（理想化：因为不能预知之后要使用的页面序列）

性能最好（条件：可预知）

![image-20250608130349422](https://gitee.com/young-lion/picture-bed/raw/master/202506081303324.png)

#### 先进先出置换算法（FIFO）

算法性能最差

![image-20250608130829606](https://gitee.com/young-lion/picture-bed/raw/master/202506081308302.png)

#### 最近最久未使用置换算法（LRU）

![image-20250608131114615](https://gitee.com/young-lion/picture-bed/raw/master/202506081311125.png)

#### 时钟置换算法（CLOCK）

![image-20250608132538966](https://gitee.com/young-lion/picture-bed/raw/master/202506081325137.png)

#### 页面分配策略

![image-20250608133429621](https://gitee.com/young-lion/picture-bed/raw/master/202506081334714.png)

何时调入？

![image-20250608134525377](https://gitee.com/young-lion/picture-bed/raw/master/202506081345129.png)

何处调入？

![image-20250608134747275](https://gitee.com/young-lion/picture-bed/raw/master/202506081347920.png)

工作集：为了解决抖动（颠簸）现象

抖动（颠簸）现象：页面频繁换入换出的现象。主要原因：分配给进程的物理块不够

![image-20250608135051658](https://gitee.com/young-lion/picture-bed/raw/master/202506081350842.png)

![image-20250608135107659](https://gitee.com/young-lion/picture-bed/raw/master/202506081351904.png)

#### 内存映射文件

![image-20250608140843027](https://gitee.com/young-lion/picture-bed/raw/master/202506081408298.png)

#### 小结

**一、内存管理概述**

- **核心目标**：高效、安全地分配和管理内存资源，提升内存利用率，保障多进程间内存隔离与数据安全。
- **关键功能**：内存分配与回收、内存保护、地址映射、内存扩充（虚拟内存技术）。

**二、内存管理基本技术**

（一）**连续分配管理方式**

1. 单一连续分配
   - **特点**：内存分为系统区和用户区，仅允许单个用户进程运行。
   - **优缺点**：实现简单，但内存利用率极低，仅适用于单道程序环境。
2. 固定分区分配
   - **特点**：将内存划分为若干固定大小的分区，每个分区可装入一个进程。
   - **优缺点**：支持多道程序，存在内部碎片（分区内未被利用空间），分区大小固定导致大进程无法装入。
3. 动态分区分配（可变分区分配）
   - **特点**：根据进程实际需求动态划分内存分区，分区大小随进程变化。
   - 内存分配算法
     - **首次适应算法**：从低地址开始查找第一个足够大的空闲分区，简单高效，易产生碎片。
     - **最佳适应算法**：选择与进程大小最接近的空闲分区，易产生大量微小碎片。
     - **最坏适应算法**：选择最大的空闲分区，减少碎片但可能导致大分区被分割。
   - **优缺点**：无内部碎片，但存在外部碎片（分散的小空闲分区），需紧凑技术（内存移动合并碎片）辅助。

（二）**非连续分配管理方式**

1. 分页存储管理
   - **基本思想**：将内存和进程划分为大小相等的页（内存物理块）和页框，通过页表实现逻辑地址到物理地址的映射。
   - 关键概念
     - **页号**：逻辑地址高位，对应页表索引。
     - **页内偏移量**：逻辑地址低位，确定页内具体位置。
     - **页表**：记录页号与物理块号的映射关系，存于内存，查询需一次访存。
   - **优缺点**：无外部碎片，内存利用率高，支持虚拟内存；存在页内碎片（每页最后部分可能未被利用），地址转换开销较大。
2. 分段存储管理
   - **基本思想**：按程序逻辑结构（如代码段、数据段、栈段）划分为若干段，每段有独立段名和长度，通过段表映射逻辑段到物理内存。
   - 关键概念
     - **段号**：逻辑地址高位，标识段类型和功能。
     - **段内偏移量**：逻辑地址低位，确定段内具体位置。
     - **段表**：记录段号、段长和基址，检查偏移量是否越界（段内偏移量≤段长）。
   - **优缺点**：便于程序模块化设计和共享，支持动态链接；存在外部碎片，地址转换需两次访存。
3. 段页式存储管理
   - **基本思想**：结合分段和分页，先将进程分为若干段，每段再划分为若干页，通过段表和页表实现两级地址映射。
   - **地址转换过程**：逻辑地址→段表（查段对应的页表基址）→页表（查页对应的物理块号）→物理地址，需三次访存（引入快表可加速）。
   - **优缺点**：兼具分段和分页优势，减少碎片，支持动态链接和共享；结构复杂，地址转换开销大。

**三、虚拟内存技术**

（一）**核心思想**

- 基于局部性原理（进程在一段时间内集中访问部分区域），允许进程仅装入部分页面 / 段到内存，其余数据存于外存，运行时按需调入（请求调页 / 段），实现 “内存不足时运行大程序” 的效果。

（二）**关键技术**

1. 请求分页存储管理

   - **与分页的区别**：页表增加状态位（是否在内存）、访问位（记录访问频率）、修改位（是否被修改），支持缺页中断（进程访问不在内存的页时触发，调入页面）。

   - 页面置换算法

     ：当内存无空闲块时，选择淘汰页面的策略。

     - **最佳置换算法（OPT）**：理论上最优，淘汰最远将来才使用的页，无法实现，用于性能对比。
     - **先进先出算法（FIFO）**：淘汰最早进入内存的页，可能产生 “Belady 现象”（增加物理块数反而使缺页率上升）。
     - **最近最久未使用算法（LRU）**：淘汰最长时间未访问的页，需记录页访问时间，硬件成本高（可用寄存器或栈实现近似算法）。
     - **Clock 算法（最近未使用算法，NRU）**：通过访问位标记页是否被访问，淘汰未被访问的页，简单高效。

2. **请求分段存储管理**：类似请求分页，增加段的状态位和缺段中断，支持段的动态增长和共享。

（三）**内存扩充效果**

- 逻辑地址空间远大于物理内存空间，提升多道程序并发度，但需注意缺页 / 段率过高导致的 “抖动”（频繁内外存交换，系统性能急剧下降）。

**四、内存保护机制**

- **目的**：防止进程越权访问或破坏其他进程 / 系统内存数据。
- 实现方式
  - **界限寄存器**：设置上下界寄存器，检查进程访问地址是否在合法范围内。
  - **存储键与访问权字节**：内存块分配存储键，进程持访问权字节（密钥），匹配则允许访问。
- **与地址映射结合**：在地址转换过程中同步检查访问权限，确保安全。

**五、总结对比**

| 管理方式                  | 连续 / 非连续 | 主要碎片类型                            | 典型应用场景                                      |
| ------------------------- | ------------- | --------------------------------------- | ------------------------------------------------- |
| 单一连续分配              | 连续          | 无（仅单进程）                          | 早期单用户系统（如 DOS 雏形）                     |
| 固定分区分配              | 连续          | 内部碎片                                | 简单多道程序系统（如早期批处理系统）              |
| 动态分区分配              | 连续          | 外部碎片                                | 需动态适应进程大小的系统（需紧凑技术）            |
| 分页管理                  | 非连续        | 页内碎片（内部）                        | 现代操作系统基础（如 Linux 内存管理基础）         |
| 分段管理                  | 非连续        | 外部碎片                                | 支持程序模块化的系统（如早期 UNIX）               |
| 段页式管理                | 非连续        | 页内碎片                                | 复杂系统（如 Windows 早期版本）                   |
| 虚拟内存（请求分页 / 段） | 非连续        | 页内碎片 + 外部碎片（通过置换算法缓解） | 多任务、大程序运行的现代系统（如 Linux、Windows） |

**重点总结**：内存管理围绕 “高效分配、安全隔离、虚拟扩充” 展开，连续分配简单但碎片问题严重，非连续分配（分页 / 分段）是主流，虚拟内存技术突破物理内存限制，保护机制确保系统稳定。不同场景需权衡碎片、性能和实现复杂度选择合适方案。

## 第四章 文件管理

### 初识文件管理

![image-20250609170017984](https://gitee.com/young-lion/picture-bed/raw/master/202506091700215.png)

### 文件的逻辑结构

![image-20250609170254356](https://gitee.com/young-lion/picture-bed/raw/master/202506091702410.png)

![image-20250609171534938](https://gitee.com/young-lion/picture-bed/raw/master/202506091715903.png)

![image-20250609171822749](https://gitee.com/young-lion/picture-bed/raw/master/202506091718649.png)

索引文件：其实就是为了解决在实际应用中，我们的信息几乎都是一个个的无定长的记录。在顺序文件中，无定长记录是按照一种“链表”的方式   进行数据的组织形式的。因此，在查询时需要一个一个查询。那么索引文件通过建立“基于定长记录的顺序文件（索引表） ” + 对逻辑文件的映射，达到快速查询的目的。如果按照关键字排列，还可以支持关键字的折半查找。

![image-20250609173453028](https://gitee.com/young-lion/picture-bed/raw/master/202506091734190.png)

![image-20250609173511493](https://gitee.com/young-lion/picture-bed/raw/master/202506091735576.png)

![image-20250609173019823](https://gitee.com/young-lion/picture-bed/raw/master/202506091730652.png)

### 文件目录

文件管理的核心数据结构

![image-20250609174031173](https://gitee.com/young-lion/picture-bed/raw/master/202506091740216.png)

#### 目录结构

![image-20250609174425249](https://gitee.com/young-lion/picture-bed/raw/master/202506091744439.png)

![image-20250609174543389](https://gitee.com/young-lion/picture-bed/raw/master/202506091745412.png)

![image-20250609174944326](https://gitee.com/young-lion/picture-bed/raw/master/202506091749215.png)

![image-20250609175130842](https://gitee.com/young-lion/picture-bed/raw/master/202506091751899.png)

#### 文件目录小结

![image-20250609175828134](https://gitee.com/young-lion/picture-bed/raw/master/202506091758379.png)

### 文件的物理结构和文件分配方式

**一、核心概念：物理结构与分配方式的定义**

**1. 文件的物理结构**

- **定义**：指文件数据在存储设备（如磁盘）上的**实际存储形态与组织方式**，即数据块如何排列、链接或索引，体现数据的 “存储布局”。
- **关注点**：数据块的逻辑关系（连续 / 离散）、是否需要指针 / 索引、访问数据的路径。

**2. 文件的分配方式**

- **定义**：操作系统为文件**分配存储空间的策略**，决定如何从存储设备中申请、管理和回收磁盘块，是物理结构的实现基础。
- **关注点**：分配策略（连续分配 / 离散分配）、空间管理效率、碎片处理。

**二、文件分配方式的分类与对应物理结构**

| **分配方式** | **核心策略**                                                 | **对应物理结构** | **典型场景 / 文件系统**                      | **优缺点**                                                   |
| ------------ | ------------------------------------------------------------ | ---------------- | -------------------------------------------- | ------------------------------------------------------------ |
| **连续分配** | 为文件分配**连续的磁盘块**，通过起始地址和块数定位数据。     | 连续结构         | 早期机械硬盘、简单文件系统（如 MS-DOS 早期） | **优点**：访问速度快，支持顺序 / 随机访问； **缺点**：易产生外部碎片，文件扩展困难。 |
| **链式分配** | 为文件分配**离散的磁盘块**，通过指针（前一块存储下一块地址）串联数据块。 | 链接结构         | FAT 文件系统（隐式 / 显式链接）              | **优点**：充分利用离散空间，无外部碎片； **缺点**：只能顺序访问，指针存储开销。 |
| **索引分配** | 为文件创建**索引表**（记录所有数据块地址），磁盘块可离散分配，通过索引表访问。 | 索引结构         | EXT4、NTFS、APFS 等现代文件系统              | **优点**：支持高效随机访问，便于文件扩展； **缺点**：索引表占用额外空间。 |

**三、关键对应关系与逻辑**

1. **分配方式决定物理结构**
   - 分配方式是 “策略”，物理结构是 “结果”。例如：
     - 选择**连续分配** → 数据块必然连续存储（连续结构）；
     - 选择**链式分配** → 数据块离散存储并通过指针链接（链接结构）；
     - 选择**索引分配** → 数据块离散存储但通过索引表统一管理（索引结构）。
2. **核心差异：策略 vs. 形态**
   - **分配方式**：解决 “如何分空间”（连续分 / 离散分），涉及操作系统的存储管理策略；
   - **物理结构**：解决 “分完后数据怎么存”（排成一排 / 用指针连起来 / 用索引表管起来），是分配策略的具体体现。
3. **应用场景对比**
   - **连续结构**：适合对访问速度要求高且不常修改的文件（如系统文件），但空间利用率低；
   - **链接结构**：适合顺序访问的大文件（如日志文件），但随机访问效率差；
   - **索引结构**：适合需要频繁随机访问的文件（如数据库文件），是现代文件系统的主流选择。

**四、常见问题与总结**

**1. 为什么分配方式影响物理结构？**

- 分配策略直接决定数据块的存储位置（连续或离散），而存储位置的组织方式（是否用指针 / 索引）即物理结构。例如，离散分配必须通过指针或索引来建立数据块的逻辑关联。

**2. 碎片问题如何产生？**

- **连续分配**：文件删除后，连续空间被分割为不连续的小块，形成**外部碎片**；
- **链式 / 索引分配**：数据块本身离散存储，无外部碎片，但可能产生**内部碎片**（如索引表占用空间）。

**3. 总结图示**

```plaintext
分配方式（策略）   →   物理结构（结果）  
├─ 连续分配       →   连续存储（无指针/索引）  
├─ 链式分配       →   离散存储+指针链接  
└─ 索引分配       →   离散存储+索引表管理  
```

通过分配方式与物理结构的绑定关系，操作系统实现了对文件存储的高效管理，平衡了空间利用率与访问性能的需求。

### ==文件存储空间管理（没懂）==

![image-20250611144930474](https://gitee.com/young-lion/picture-bed/raw/master/202506111449728.png)

### 文件的基本操作

![image-20250611145255741](https://gitee.com/young-lion/picture-bed/raw/master/202506111452667.png)

![image-20250611145437774](https://gitee.com/young-lion/picture-bed/raw/master/202506111454503.png)

<img src="https://gitee.com/young-lion/picture-bed/raw/master/202506111503355.png" alt="image-20250611150312587" />

![image-20250611150253296](https://gitee.com/young-lion/picture-bed/raw/master/202506111502225.png)

![image-20250611150858247](https://gitee.com/young-lion/picture-bed/raw/master/202506111509332.png)

### 文件共享

共享方式：

![image-20250611151804155](https://gitee.com/young-lion/picture-bed/raw/master/202506111518041.png)

### 文件保护

![image-20250611153328362](https://gitee.com/young-lion/picture-bed/raw/master/202506111533294.png)

### 文件系统的层次结构

![image-20250611153742282](https://gitee.com/young-lion/picture-bed/raw/master/202506111537515.png)

![image-20250611154051759](https://gitee.com/young-lion/picture-bed/raw/master/202506111540132.png)

### 文件系统布局

物理格式化、逻辑格式化、内存中的文件系统结构

### 虚拟文件系统和文件系统挂载

虚拟文件系统：相当于一种接口的作用

![image-20250611165353473](https://gitee.com/young-lion/picture-bed/raw/master/202506111653229.png)

2.对上（应用进程），屏蔽实现。对下（内核），要求必须按照“接口”进行实现。

![image-20250611165853982](https://gitee.com/young-lion/picture-bed/raw/master/202506111720355.png)

![image-20250611170231246](https://gitee.com/young-lion/picture-bed/raw/master/202506111702559.png)

![image-20250611171321760](https://gitee.com/young-lion/picture-bed/raw/master/202506111713042.png)

### 小结

**一、文件管理：核心功能与目标**

- **核心职责**：统一管理文件的存储、检索、保护，提供抽象接口屏蔽底层硬件差异。
- **关键目标**：高效性（减少 I/O）、安全性（权限控制）、透明性（用户无需关心物理存储）。
- **辨析**：文件管理与存储管理的区别 —— 前者聚焦数据组织与抽象接口，后者关注内存 / 外存的物理空间分配。

**二、逻辑结构：用户视角的文件组织**

1. 无结构（流式文件）
   - 示例：文本文件（.txt）、二进制文件（.exe），视为无差别的字节流。
   - 优势：灵活，适用于任意数据；缺点：需应用层自行解析结构。
2. 有结构（记录式文件）
   - 按记录单位组织（如数据库表每条记录为一行），支持按关键字检索（如索引文件）。
   - 辨析：逻辑结构与物理结构解耦 —— 同一逻辑结构可对应不同物理存储方式（如连续 / 索引存储）。

**三、物理结构：磁盘上的数据布局**

| **类型**     | **实现方式**                          | **典型场景**            | **优缺点**                                                   |
| ------------ | ------------------------------------- | ----------------------- | ------------------------------------------------------------ |
| **连续存储** | 数据块在磁盘上连续存放                | FAT32 早期文件系统      | 读速度快，但扩展困难（需连续空间），碎片问题严重。           |
| **链式存储** | 块间通过指针链接（显式 / 隐式）       | 早期 U 盘、简单文件系统 | 适合零散空间，扩展灵活；但随机访问需遍历链表，效率低。       |
| **索引存储** | 用索引表记录所有块地址（单级 / 多级） | EXT4、NTFS、XFS         | 支持高效随机访问（直接查索引），大文件管理能力强（如 EXT4 支持 TB 级文件）。 |

- **辨析**：物理结构影响 I/O 性能 —— 索引存储在随机访问场景（如数据库）中显著优于链式存储，但索引表本身占用空间。

**四、存储空间管理：磁盘块的分配与回收**

1. 分配方法
   - **位图法**：用二进制位表示块是否空闲（1 = 已用，0 = 空闲），查询效率高（如 FAT32 的 FAT 表）。
   - **空闲链表**：将空闲块连成链表，分配时遍历查找（适合小文件系统）。
   - **成组链接法**：结合位图与链表，Linux ext 系列文件系统采用，兼顾效率与空间。
2. **回收策略**：释放块时更新空闲状态（如位图置 0），注意避免 “空闲块丢失”（如文件删除时未正确回收块）。

**五、基本操作：系统调用与语义**

| **操作**          | **核心功能**                           | **系统调用示例（Linux）** | **关键细节**                                                 |
| ----------------- | -------------------------------------- | ------------------------- | ------------------------------------------------------------ |
| **打开（Open）**  | 验证权限，获取文件句柄，初始化读写位置 | `open()`                  | 打开时指定模式（读 / 写 / 追加），返回文件描述符（fd）。     |
| **读写（I/O）**   | 按偏移量操作数据，支持缓冲             | `read()/write()`          | 内核通过页缓存（Page Cache）减少磁盘 I/O，写操作可能延迟刷盘（Delayed Write）。 |
| **定位（Lseek）** | 修改当前读写位置                       | `lseek()`                 | 支持绝对定位（如`SEEK_SET`）和相对定位（如`SEEK_CUR`）。     |
| **关闭（Close）** | 释放句柄，刷新缓存                     | `close()`                 | 引用计数减 1，为 0 时真正释放资源，避免句柄泄漏。            |

- **辨析**：缓冲 I/O 与直接 I/O—— 前者利用内存缓存提升性能（如`fread`），后者绕过缓存（如`O_DIRECT`标志，适合数据库）。

**六、文件共享：多进程协作与资源复用**

1. 共享机制
   - **文件描述符表**：进程级，记录打开文件的读写位置等状态。
   - **打开文件表**：系统级，记录文件的 inode、引用计数、权限等，实现跨进程共享。
   - **硬链接（Hard Link）**：多个文件名指向同一 inode（如 Linux 的`ln`命令），共享数据块。
   - **软链接（Symbolic Link）**：类似快捷方式，存储目标路径，可跨文件系统（如`ln -s`）。
2. 并发控制
   - **文件锁**：互斥锁（独占写）与共享锁（允许多读），通过`flock()`或`fcntl()`实现。
   - **辨析**：硬链接与软链接的本质区别 —— 硬链接无独立 inode，不能指向目录；软链接有独立 inode，可指向任意文件 / 目录，删除原文件后失效。

**七、文件保护：权限、加密与一致性**

1. 访问控制模型
   - **Unix 权限模型**：基于所有者（User）、组（Group）、其他（Others）的 r/w/x 权限（如`chmod 755`）。
   - **ACL（访问控制列表）**：Windows / 现代 Linux 支持，更精细控制（如指定用户 A 可读，用户 B 可写）。
2. 数据安全
   - 加密：透明加密（如 Linux 的 eCryptfs）对用户透明，存储时自动加密。
   - 校验：通过 CRC、哈希（如 MD5）防止数据篡改。
3. 一致性保障
   - 日志文件系统（如 EXT4、NTFS）：记录关键操作（如写块），崩溃后通过日志恢复（类似数据库事务）。

**八、文件系统层次结构与布局**

1. 逻辑分层
   - **用户接口层**：处理路径解析（如`/home/user/file.txt`），调用下层接口。
   - **文件目录层**：管理目录树、inode 映射（如通过文件名查 inode）。
   - **存储管理层**：负责块分配、缓存管理（如页缓存、预读策略）。
   - **设备接口层**：与磁盘驱动交互，执行实际 I/O 操作（如扇区读写）。
2. 物理布局（以 Linux EXT4 为例）
   - **引导块（Boot Block）**：存储启动代码，每个分区一个。
   - **超级块（Superblock）**：记录文件系统元数据（块大小、inode 总数、空闲块数等）。
   - **inode 表**：存储所有文件的 inode（元数据 + 块地址）。
   - **数据块区**：实际存储文件数据。

**九、虚拟文件系统（VFS）与挂载**

1. VFS：统一文件系统接口
   - 抽象层，屏蔽不同文件系统（EXT4/NTFS/FAT32）的差异，提供统一系统调用接口。
   - 核心数据结构：`struct file`（文件实例）、`struct inode`（VFS 层 inode）、`struct super_block`（超级块）。
2. 挂载（Mount）
   - 将外部存储设备（如 U 盘）或文件系统关联到目录树的过程（如 Linux 中`mount /dev/sdb1 /mnt/usb`）。
   - 关键步骤：
     1. 解析设备路径，读取超级块；
     2. 在 VFS 中注册文件系统类型；
     3. 将设备挂载点（如`/mnt/usb`）与文件系统根目录关联。

- **辨析**：VFS 与具体文件系统的关系 ——VFS 是 “接口规范”，EXT4/NTFS 等是 “实现”，类似面向对象中的接口与类。

**总结：核心辨析与关联**

- **逻辑结构 vs 物理结构**：前者是用户视角的抽象（如记录式文件），后者是磁盘存储的具体实现（如索引存储），通过文件系统层解耦。
- **文件共享 vs 文件保护**：共享需并发控制（锁机制），保护需权限隔离，二者通过打开文件表、ACL 等机制协同。
- **VFS 的核心价值**：屏蔽不同文件系统差异，使`open()/read()`等接口可操作本地磁盘、U 盘、网络文件系统（如 NFS）等，实现 “一切皆文件” 的抽象。

## 第五章 设备管理

### io设备的概念和分类

概念：向外部输入和输出的设备

使用特性分类：人机交互型（鼠标等外设）、存储设备（移动硬盘等）、网络通信设备（光猫等）

传输速率分类：低速、中速、高速

信息交换的单位分类：块设备（传输速率较高、可寻址对他可随机读写任一块）如：磁盘等——数据传输的基本单位是“块”、字符设备（传输速率较慢、不可寻址、在输入/输出时常采用中断驱动方式）——数据传输的基本单位是字符。

### io控制器

![image-20250613112354796](https://gitee.com/young-lion/picture-bed/raw/master/202506131124324.png)

![image-20250613112953232](https://gitee.com/young-lion/picture-bed/raw/master/202506131129026.png)

![image-20250613113241092](https://gitee.com/young-lion/picture-bed/raw/master/202506131132111.png)

### io控制方式

![image-20250613113425432](https://gitee.com/young-lion/picture-bed/raw/master/202506131134133.png)

![image-20250613115725989](https://gitee.com/young-lion/picture-bed/raw/master/202506131157739.png)
