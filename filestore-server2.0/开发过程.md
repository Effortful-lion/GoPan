# 开发一：完成基本的文件上传服务
1. 返回文件上传页面
2. 选取本地文件，form上传
3. 云端接收并保存到本地文件系统
4. 云端更新文件元信息集合
5. 删除、查询功能
6. 下载功能（加载并返回）
7. 文件信息存储在内存中，重启后丢失（问题）

# 开发二：基于mysql存储文件元信息
1. 为什么使用mysql？
   1. 数据量不大、用户数也不大
   2. 小、稳定、社区活跃
   3. 在当前项目场景下，mysql足够进行文件元信息的存储
2. 使用mysql主从集群
   1. 实现读写分离：主数据库负责写请求，从数据库负责读请求。
   2. 提高性能：从数据库可以处理更多的读请求，从而提高系统的整体性能。
   3. 同步数据，提高数据一致性
   4. 故障回复：主数据库发生故障时，可以切换到从数据库，保证系统的可用性。
3. 分库分表
   1. 水平分库：将数据分散到多个数据库中，每个数据库存储一部分数据。
   2. 水平分表：将数据分散到多个表中，每个表存储一部分数据。
   3. 垂直分表：将数据不同字段分散到不同的表中，每个表存储一部分字段的数据。
   4. 举例：比如在这里怎么分表
      假设分成256张表：
      按照文件sha1值的后两位切分，后两位每位是0-15，因此从 00 到 ff，共256张表。
   5. 我们这里先用简单的单表

# 开发三：账号系统
1. 注册、登录
2. 用户登录session/token
3. 用户资源隔离
4. 云端资源共享管理

# 开发四：文件秒传
1. 云端存储文件哈希值
2. 客户端上传文件时，先计算文件哈希值（如果没有计算，那么就不会触发秒传）
3. 对于其中处理相同文件的逻辑：
   1. 允许不同用户上传相同文件
   2. 先上传完成的先落库
   3. 对于之后上传的相同的文件，只更新用户文件表就可以了，文件通过哈希值共享
4. hash算法的应用场景和区别：crc、md5、sha1.
   1. 长度、大小：crc 16位，md5 128位，sha1 160位
   2. 速度：crc 最快，md5 次之，sha1 最慢
   3. 碰撞概率：crc 极低，md5 较低，sha1 极低
   4. 应用场景：crc 用于校验数据传输，md5 用于校验数据完整性，sha1 用于校验数据完整性和防篡改

# 开发五：断点续传和分块上传
1. 小文件不适合分块上次
2. 可以并行上传分块，且可以无序传输
3. 分块上传可以极大提高文件上传的效率，尤其是对于大文件。
4. 断点续传：减少传输失败后的重试次数，提高上传效率。（部分已经传输成功了，不需要全部重传）
5. 分块上传流程：
   服务端（括号中：客户端）：
      1. 初始化分块信息（客户端从接口中获取到 上传的唯一id 和 分块的规则）
      2. 上传分块
      3. 通知上传成功
      4. 取消上传分块
      5. 查看分块上传的整体进度
6. 测试断点续传：
   1. 调接口1：就是将分块上传中断（取消分块上传）
   2. 调接口2：获取分块上传进度，得到 百分比 + 还需要上传的分块列表

# 开发六：阿里云oss存储
1. 阿里云oss存储：对象存储服务，用于存储和管理非结构化数据，如图片、视频、音频、文档等。
2. 为什么使用阿里云oss存储：
   1. 可靠性：服务可用、数据持久
   2. 安全性：资源隔离存储、访问鉴权
   3. 易用性：restfulapi接口、SDK
   4. 处理能力：海量规模、图片处理、音视频转码(各种清晰度)...
3. 注意：配置子用户，授权oss服务权限
4. 很多问题可能是网络的问题

# 开发七：Rabbitmq实现异步转移服务
1. 接入消息队列后的上传步骤：
   1. 客户端上传请求 到 服务端上传服务
   2. 服务端上传服务 立刻响应 客户端
   3. 服务端将文件 临时保存到本地服务器，将本地临时路径保存到mysql中（防止在响应后和真正上传前，用户发送请求时，可以直接访问服务器上的临时文件）
   4. 服务端另外开一个协程 监听消息队列的上传任务队列
   5. 接收任务，读取临时文件
   6. 执行真正的上传逻辑
   7. 上传成功后，删除临时文件，更新真实文件存储路径
2. 组件：
   Exchange：消息交换机，决定消息路由规则，可转发到多个队列（消息接收和转发）
   Queue：消息载体，存储待消费消息（消息存储）
   Binding：绑定动作，建立交换机和队列的路由规则（路由规则映射关系）通过 Binding Key 定义路由规则 
   Binding Key：绑定键，用于定义消息路由规则（定义路由规则）
   Routing Key：路由键，生产者发布时指定，决定消息路由目标（路由key-->指导交换机 向特定的队列发送消息）
   Channel：消息通道，客户端与RabbitMQ建立的连接管道（消息投放对象）
   // 以下是用户需要实现的部分
   Producer：消息生产者（同Publisher）
   Consumer：消息消费者，通过长连接持续接收消息
3. 工作模式：
   1. fanout：广播模式，将消息路由到所有绑定的队列
   2. direct：定向模式，将消息一对一路由到指定的队列（Routing Key--Binding Key 1:1）
   3. Topic ：通配符模式，将消息路由到符合指定路由规则的队列（（具体的路由键）Routing Key--（支持通配符）Binding Key m:n）
   4. Headers：头信息模式，请求头和消息头匹配时，才能接收消息

# 开发八：微服务化
步骤：
